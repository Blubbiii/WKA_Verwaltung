import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { requirePermission } from "@/lib/auth/withPermission";
import { z } from "zod";
import { apiLogger as logger } from "@/lib/logger";

// =============================================================================
// VALIDATION
// =============================================================================

const autoGenerateSchema = z.object({
  parkId: z.string().min(1, "Park-ID ist erforderlich"),
});

// =============================================================================
// POST /api/energy/topology/auto-generate
// Auto-generate a topology layout from existing turbines
// =============================================================================

export async function POST(request: NextRequest) {
  try {
    const check = await requirePermission("energy:create");
    if (!check.authorized) return check.error;

    const body = await request.json();
    const validated = autoGenerateSchema.parse(body);

    // Verify park and get turbines
    const park = await prisma.park.findFirst({
      where: {
        id: validated.parkId,
        tenantId: check.tenantId!,
      },
      select: {
        id: true,
        name: true,
        shortName: true,
      },
    });

    if (!park) {
      return NextResponse.json(
        { error: "Park nicht gefunden oder keine Berechtigung" },
        { status: 404 }
      );
    }

    const turbines = await prisma.turbine.findMany({
      where: {
        parkId: validated.parkId,
        park: { tenantId: check.tenantId! },
      },
      select: {
        id: true,
        designation: true,
        manufacturer: true,
        model: true,
        ratedPowerKw: true,
        status: true,
        deviceType: true,
      },
      orderBy: { designation: "asc" },
    });

    if (turbines.length === 0) {
      return NextResponse.json(
        { error: "Keine Turbinen in diesem Park vorhanden" },
        { status: 400 }
      );
    }

    // Generate layout: NVP in center, turbines in a circle around it
    const centerX = 50;
    const centerY = 50;
    const radius = 35; // Radius for turbine circle placement

    // Run in a transaction: delete old topology, create new one
    const result = await prisma.$transaction(async (tx) => {
      // Delete existing topology for this park
      await tx.networkConnection.deleteMany({
        where: {
          tenantId: check.tenantId!,
          fromNode: { parkId: validated.parkId },
        },
      });
      await tx.networkNode.deleteMany({
        where: {
          tenantId: check.tenantId!,
          parkId: validated.parkId,
        },
      });

      // Create NVP node at center
      const nvpNode = await tx.networkNode.create({
        data: {
          tenantId: check.tenantId!,
          parkId: validated.parkId,
          name: "NVP",
          type: "NVP",
          posX: centerX,
          posY: centerY,
          metadata: { autoGenerated: true },
        },
      });

      // Create turbine nodes in a circle
      const createdNodes = [nvpNode];
      const turbineNodes = [];

      for (let i = 0; i < turbines.length; i++) {
        const angle = (2 * Math.PI * i) / turbines.length - Math.PI / 2;
        const posX = Math.round((centerX + radius * Math.cos(angle)) * 100) / 100;
        const posY = Math.round((centerY + radius * Math.sin(angle)) * 100) / 100;

        // Clamp values to 2-98 range for visual padding
        const clampedX = Math.max(5, Math.min(95, posX));
        const clampedY = Math.max(5, Math.min(95, posY));

        const turbineNode = await tx.networkNode.create({
          data: {
            tenantId: check.tenantId!,
            parkId: validated.parkId,
            name: turbines[i].designation,
            type: "TURBINE",
            posX: clampedX,
            posY: clampedY,
            turbineId: turbines[i].id,
            metadata: { autoGenerated: true },
          },
          include: {
            turbine: {
              select: {
                id: true,
                designation: true,
                manufacturer: true,
                model: true,
                ratedPowerKw: true,
                status: true,
                deviceType: true,
              },
            },
          },
        });

        createdNodes.push(turbineNode);
        turbineNodes.push(turbineNode);
      }

      // Create connections: each turbine connects to the NVP (star topology)
      const createdConnections = [];

      for (const turbineNode of turbineNodes) {
        const connection = await tx.networkConnection.create({
          data: {
            tenantId: check.tenantId!,
            fromNodeId: turbineNode.id,
            toNodeId: nvpNode.id,
            cableType: "20kV",
            metadata: { autoGenerated: true },
          },
        });
        createdConnections.push(connection);
      }

      return {
        nodes: createdNodes,
        connections: createdConnections,
      };
    });

    return NextResponse.json(
      {
        ...result,
        park,
      },
      { status: 201 }
    );
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validierungsfehler", details: error.errors },
        { status: 400 }
      );
    }
    logger.error({ err: error }, "Error auto-generating topology");
    return NextResponse.json(
      { error: "Fehler beim Generieren der Topologie" },
      { status: 500 }
    );
  }
}
